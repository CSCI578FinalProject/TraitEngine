12
-----CSCI578-----



    public ApplicationPushBuilder setHeader(String name, String value) {
        List<String> values = headers.get(name);
        if (values == null) {
            values = new ArrayList<>();
            headers.put(name, values);
        } else {
            values.clear();
        }
        values.add(value);

        return this;
    }
-----CSCI578-----


    public boolean getResult() {
        return result.get();
    }
-----CSCI578-----



    // Package private so it can be tested. charsetName must be in lower case.
    static String decode(String input, String charsetName) {
        int start = input.indexOf('%');
        int end = 0;

        // Shortcut
        if (start == -1) {
            return input;
        }

        Charset charset;
        try {
            charset = B2CConverter.getCharsetLower(charsetName);
        } catch (UnsupportedEncodingException uee) {
            // Impossible since original request would have triggered an error
            // before reaching here
            throw new IllegalStateException(uee);
        }

        StringBuilder result = new StringBuilder(input.length());
        while (start != -1) {
            // Found the start of a %nn sequence. Copy everything form the last
            // end to this start to the output.
            result.append(input.substring(end, start));
            // Advance the end 3 characters: %nn
            end = start + 3;
            while (end <input.length() && input.charAt(end) == '%') {
                end += 3;
            }
            result.append(decode(input.substring(start, end), charset));
            start = input.indexOf('%', end);
        }
        // Append the remaining text
        result.append(input.substring(end));

        return result.toString();
    }



    private static String decode(String percentSequence, Charset charset) {
        byte[] bytes = new byte[percentSequence.length()/3];
        for (int i = 0; i < bytes.length; i += 3) {
            bytes[i] = (byte) (HexUtils.getDec(percentSequence.charAt(1 + 3 * i)) << 4 +
                    HexUtils.getDec(percentSequence.charAt(2 + 3 * i)));
        }

        return new String(bytes, charset);
    }
-----CSCI578-----



    private static String generateCookieHeader(List<Cookie> cookies, CookieProcessor cookieProcessor) {
        StringBuilder result = new StringBuilder();
        boolean first = true;
        for (Cookie cookie : cookies) {
            if (first) {
                first = false;
            } else {
                result.append(';');
            }
            // The cookie header value generated by the CookieProcessor was
            // originally intended for the Set-Cookie header on the response.
            // However, if passed a Cookie with just a name and value set it
            // will generate an appropriate header for the Cookie header on the
            // pushed request.
            result.append(cookieProcessor.generateHeader(cookie));
        }
        return result.toString();
    }
-----CSCI578-----



    public boolean push() {
        if (path == null) {
            throw new IllegalStateException(sm.getString("pushBuilder.noPath"));
        }

        org.apache.coyote.Request pushTarget = new org.apache.coyote.Request();

        pushTarget.method().setString(method);
        // The next three are implied by the Javadoc getPath()
        pushTarget.serverName().setString(baseRequest.getServerName());
        pushTarget.setServerPort(baseRequest.getServerPort());
        pushTarget.scheme().setString(baseRequest.getScheme());

        // Copy headers
        for (Map.Entry<String,List<String>> header : headers.entrySet()) {
            for (String value : header.getValue()) {
                pushTarget.getMimeHeaders().addValue(header.getKey()).setString(value);
            }
        }

        // Path and query string
        int queryIndex = path.indexOf('?');
        String pushPath;
        String pushQueryString = null;
        if (queryIndex > -1) {
            pushPath = path.substring(0, queryIndex);
            if (queryIndex + 1 < path.length()) {
                pushQueryString = path.substring(queryIndex + 1);
            }
        } else {
            pushPath = path;
        }

        // Session ID (do this before setting the path since it may change it)
        if (sessionId != null) {
            if (addSessionPathParameter) {
                pushPath = pushPath + ";" + sessionPathParameterName + "=" + sessionId;
                pushTarget.addPathParameter(sessionPathParameterName, sessionId);
            }
            if (addSessionCookie) {
                cookies.add(new Cookie(sessionCookieName, sessionId));
            }
        }

        // Undecoded path - just %nn encoded
        pushTarget.requestURI().setString(pushPath);
        pushTarget.decodedURI().setString(decode(pushPath,
                catalinaRequest.getConnector().getURIEncodingLower()));

        // Query string
        if (pushQueryString == null && queryString != null) {
            pushTarget.queryString().setString(queryString);
        } else if (pushQueryString != null && queryString == null) {
            pushTarget.queryString().setString(pushQueryString);
        } else if (pushQueryString != null && queryString != null) {
            pushTarget.queryString().setString(pushQueryString + "&" +queryString);
        }

        if (conditional) {
            if (etag != null) {
                setHeader("if-none-match", etag);
            } else if (lastModified != null) {
                setHeader("if-modified-since", lastModified);
            }
        }

        // Cookies
        setHeader("cookie", generateCookieHeader(cookies,
                catalinaRequest.getContext().getCookieProcessor()));

        PushToken pushToken = new PushToken(pushTarget);
        coyoteRequest.action(ActionCode.PUSH_REQUEST, pushToken);

        // Reset for next call to this method
        pushTarget = null;
        path = null;
        etag = null;
        lastModified = null;
        headers.remove("if-none-match");
        headers.remove("if-modified-since");

        return pushToken.getResult();
    }
-----CSCI578-----
-----CSCI578-----



     /**
      * @return the character encoding to be used for the URI using lower case.
      */
     public String getURIEncodingLower() {
         return this.URIEncodingLower;
     }
-----CSCI578-----


    /**
     * Only to be used when it is known that the encoding name is in lower case.
     * @param lowerCaseEnc The name of the encoding for the required charset in
     *                     lower case
     *
     * @return The Charset corresponding to the requested encoding
     *
     * @throws UnsupportedEncodingException If the requested Charset is not
     *                                      available
     */
    public static Charset getCharsetLower(String lowerCaseEnc)
            throws UnsupportedEncodingException {

        Charset charset = encodingToCharsetCache.get(lowerCaseEnc);

        if (charset == null) {
            // Pre-population of the cache means this must be invalid
            throw new UnsupportedEncodingException(
                    sm.getString("b2cConverter.unknownEncoding", lowerCaseEnc));
        }
        return charset;
    }
-----CSCI578-----



    public void addPathParameter(String name, String value) {
        pathParameters.put(name, value);
    }
-----CSCI578-----
-----CSCI578-----
-----CSCI578-----
