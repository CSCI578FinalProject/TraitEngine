20



    public void setInitialWindowSize(int initialWindowSize) {
        localSettings.set(Setting.INITIAL_WINDOW_SIZE, initialWindowSize);
    }



    public long getKeepAliveTimeout() {
        return keepAliveTimeout;
    }



    @Override
    protected synchronized void set(Setting setting, Long value) {
        checkSend();
        if (current.get(setting).longValue() == value.longValue()) {
            pending.remove(setting);
        } else {
            pending.put(setting, value);
        }
    }



    @Override
    public InternalHttpUpgradeHandler getInternalUpgradeHandler(Adapter adapter,
            Request coyoteRequest) {
        Http2UpgradeHandler result = new Http2UpgradeHandler(adapter, coyoteRequest);

        result.setReadTimeout(getReadTimeout());
        result.setKeepAliveTimeout(getKeepAliveTimeout());
        result.setWriteTimeout(getWriteTimeout());
        result.setMaxConcurrentStreams(getMaxConcurrentStreams());
        result.setInitialWindowSize(getInitialWindowSize());

        return result;
    }



    public int getInitialWindowSize() {
        return initialWindowSize;
    }



    public void setReadTimeout(long readTimeout) {
        this.readTimeout = readTimeout;
    }


    @Override
    public Processor getProcessor(SocketWrapperBase<?> socketWrapper, Adapter adapter) {
        UpgradeProcessorInternal processor = new UpgradeProcessorInternal(socketWrapper, null,
                new UpgradeToken(getInternalUpgradeHandler(adapter, null), null, null));
        return processor;
    }



    public void setKeepAliveTimeout(long keepAliveTimeout) {
        this.keepAliveTimeout = keepAliveTimeout;
    }



    public long getWriteTimeout() {
        return writeTimeout;
    }



    public void setWriteTimeout(long writeTimeout) {
        this.writeTimeout = writeTimeout;
    }



    public long getMaxConcurrentStreams() {
        return maxConcurrentStreams;
    }



    public void setMaxConcurrentStreams(long maxConcurrentStreams) {
        localSettings.set(Setting.MAX_CONCURRENT_STREAMS, maxConcurrentStreams);
    }



    public long getReadTimeout() {
        return readTimeout;
    }



    private void checkSend() {
        if (sendInProgress) {
            // Coding error. No need for i18n
            throw new IllegalStateException();
        }
    }
