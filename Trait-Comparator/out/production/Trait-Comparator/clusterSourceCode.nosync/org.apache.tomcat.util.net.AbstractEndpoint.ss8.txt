5

    protected abstract SSLHostConfig.Type getSslConfigType();



    public void setConfigType(Type configType) {
        this.configType = configType;
        if (configType == Type.EITHER) {
            if (configuredProperties.remove(Type.JSSE) == null) {
                configuredProperties.remove(Type.OPENSSL);
            }
        } else {
            configuredProperties.remove(configType);
        }
        for (Map.Entry<Type,Set<String>> entry : configuredProperties.entrySet()) {
            for (String property : entry.getValue()) {
                log.warn(sm.getString("sslHostConfig.mismatch",
                        property, getHostName(), entry.getKey(), configType));
            }
        }
    }

    public void addSslHostConfig(SSLHostConfig sslHostConfig) {
        String key = sslHostConfig.getHostName();
        if (key == null || key.length() == 0) {
            throw new IllegalArgumentException(sm.getString("endpoint.noSslHostName"));
        }
        SSLHostConfig duplicate = sslHostConfigs.put(key, sslHostConfig);
        if (duplicate != null) {
            throw new IllegalArgumentException(sm.getString("endpoint.duplicateSslHostName", key));
        }
        sslHostConfig.setConfigType(getSslConfigType());
    }



    public String getHostName() {
        return hostName;
    }



    @Override
    public void addSslHostConfig(SSLHostConfig sslHostConfig) {
        getEndpoint().addSslHostConfig(sslHostConfig);
    }
