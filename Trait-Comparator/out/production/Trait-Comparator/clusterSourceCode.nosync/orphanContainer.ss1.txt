414


    @Override
    public int hashCode() {
        if ( id == null ) return 0;
        return Arrays.hashCode(id);
    }


    public static int hashCode(byte a[]) {
        if (a == null)
            return 0;

        int result = 1;
        for (int i=0; i<a.length; i++) {
            byte element = a[i];
            result = 31 * result + element;
        }
        return result;
    }


    /**
     * memberAdded gets invoked by the interceptor below the channel
     * and the channel will broadcast it to the membership listeners
     * @param member Member - the new member
     */
    @Override
    public void memberAdded(Member member) {
        //notify upwards
        for (int i=0; i<membershipListeners.size(); i++ ) {
            MembershipListener membershipListener = membershipListeners.get(i);
            if (membershipListener != null) membershipListener.memberAdded(member);
        }
    }

    /**
     * A member was added to the group
     * @param member Member - the member that was added
     */
    public void memberAdded(Member member);


    /**
     * memberDisappeared gets invoked by the interceptor below the channel
     * and the channel will broadcast it to the membership listeners
     * @param member Member - the member that left or crashed
     */
    @Override
    public void memberDisappeared(Member member) {
        //notify upwards
        for (int i=0; i<membershipListeners.size(); i++ ) {
            MembershipListener membershipListener = membershipListeners.get(i);
            if (membershipListener != null) membershipListener.memberDisappeared(member);
        }
    }


    /**
     * A member was removed from the group<br>
     * If the member left voluntarily, the Member.getCommand will contain the Member.SHUTDOWN_PAYLOAD data
     * @param member Member
     * @see Member#SHUTDOWN_PAYLOAD
     */
    public void memberDisappeared(Member member);


    @Override
    public void memberAdded(Member member) {
        MembershipListener listener = this.listener;
        if (listener != null) {
            listener.memberAdded(member);
        }
    }


    /**
     * Callback from the impl when a new member has been received
     * @param member The member
     */
    @Override
    public void memberDisappeared(Member member) {
        MembershipListener listener = this.listener;
        if (listener != null) {
            listener.memberDisappeared(member);
        }
    }


    @Override
    public int hashCode() {
        return Arrays.hashCode(this.mapContextName);
    }



    // ------------------------------------------------ ServletResponse Methods

    /**
     * Disallow <code>reset()</code> calls on a included response.
     *
     * @exception IllegalStateException if the response has already
     *  been committed
     */
    @Override
    public void reset() {

        // If already committed, the wrapped response will throw ISE
        if (!included || getResponse().isCommitted())
            getResponse().reset();

    }



    /**
     * Disallow <code>setContentLength(int)</code> calls on an included
     * response.
     *
     * @param len The new content length
     */
    @Override
    public void setContentLength(int len) {

        if (!included)
            getResponse().setContentLength(len);

    }



    /**
     * Disallow <code>setContentLengthLong(long)</code> calls on an included
     * response.
     *
     * @param len The new content length
     */
    @Override
    public void setContentLengthLong(long len) {

        if (!included)
            getResponse().setContentLengthLong(len);

    }



    /**
     * Disallow <code>setContentType()</code> calls on an included response.
     *
     * @param type The new content type
     */
    @Override
    public void setContentType(String type) {

        if (!included)
            getResponse().setContentType(type);

    }



    /**
     * Disallow <code>setLocale()</code> calls on an included response.
     *
     * @param loc The new locale
     */
    @Override
    public void setLocale(Locale loc) {

        if (!included)
            getResponse().setLocale(loc);

    }



    /**
     * Ignore <code>setBufferSize()</code> calls on an included response.
     *
     * @param size The buffer size
     */
    @Override
    public void setBufferSize(int size) {
        if (!included)
            getResponse().setBufferSize(size);
    }



    // -------------------------------------------- HttpServletResponse Methods


    /**
     * Disallow <code>addCookie()</code> calls on an included response.
     *
     * @param cookie The new cookie
     */
    @Override
    public void addCookie(Cookie cookie) {

        if (!included)
            ((HttpServletResponse) getResponse()).addCookie(cookie);

    }



    /**
     * Disallow <code>addDateHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void addDateHeader(String name, long value) {

        if (!included)
            ((HttpServletResponse) getResponse()).addDateHeader(name, value);

    }



    /**
     * Disallow <code>addHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void addHeader(String name, String value) {

        if (!included)
            ((HttpServletResponse) getResponse()).addHeader(name, value);

    }



    /**
     * Disallow <code>addIntHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void addIntHeader(String name, int value) {

        if (!included)
            ((HttpServletResponse) getResponse()).addIntHeader(name, value);

    }



    /**
     * Disallow <code>sendError()</code> calls on an included response.
     *
     * @param sc The new status code
     *
     * @exception IOException if an input/output error occurs
     */
    @Override
    public void sendError(int sc) throws IOException {

        if (!included)
            ((HttpServletResponse) getResponse()).sendError(sc);

    }



    /**
     * Disallow <code>sendError()</code> calls on an included response.
     *
     * @param sc The new status code
     * @param msg The new message
     *
     * @exception IOException if an input/output error occurs
     */
    @Override
    public void sendError(int sc, String msg) throws IOException {

        if (!included)
            ((HttpServletResponse) getResponse()).sendError(sc, msg);

    }



    /**
     * Disallow <code>setStatus()</code> calls on an included response.
     *
     * @param sc The new status code
     * @param msg The new message
     * @deprecated As of version 2.1, due to ambiguous meaning of the message
     *             parameter. To set a status code use
     *             <code>setStatus(int)</code>, to send an error with a
     *             description use <code>sendError(int, String)</code>.
     */
    @Deprecated
    @Override
    public void setStatus(int sc, String msg) {

        if (!included)
            ((HttpServletResponse) getResponse()).setStatus(sc, msg);

    }



    /**
     * Disallow <code>sendRedirect()</code> calls on an included response.
     *
     * @param location The new location
     *
     * @exception IOException if an input/output error occurs
     */
    @Override
    public void sendRedirect(String location) throws IOException {

        if (!included)
            ((HttpServletResponse) getResponse()).sendRedirect(location);

    }



    /**
     * Disallow <code>setDateHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void setDateHeader(String name, long value) {

        if (!included)
            ((HttpServletResponse) getResponse()).setDateHeader(name, value);

    }



    /**
     * Disallow <code>setHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void setHeader(String name, String value) {

        if (!included)
            ((HttpServletResponse) getResponse()).setHeader(name, value);

    }



    /**
     * Disallow <code>setIntHeader()</code> calls on an included response.
     *
     * @param name The new header name
     * @param value The new header value
     */
    @Override
    public void setIntHeader(String name, int value) {

        if (!included)
            ((HttpServletResponse) getResponse()).setIntHeader(name, value);

    }



    /**
     * Disallow <code>setStatus()</code> calls on an included response.
     *
     * @param sc The new status code
     */
    @Override
    public void setStatus(int sc) {

        if (!included)
            ((HttpServletResponse) getResponse()).setStatus(sc);

    }



    /**
     * Disallow <code>setStatus()</code> calls on an included response.
     *
     * @param sc The new status code
     * @param msg The new message
     * @deprecated As of version 2.1, due to ambiguous meaning of the message
     *             parameter. To set a status code use
     *             <code>setStatus(int)</code>, to send an error with a
     *             description use <code>sendError(int, String)</code>.
     */
    @Deprecated
    @Override
    public void setStatus(int sc, String msg) {

        if (!included)
            ((HttpServletResponse) getResponse()).setStatus(sc, msg);

    }



    /**
     * Override the <code>removeAttribute()</code> method of the
     * wrapped request.
     *
     * @param name Name of the attribute to remove
     */
    @Override
    public void removeAttribute(String name) {

        synchronized (attributes) {
            attributes.remove(name);
            if (!isSpecial(name))
                getRequest().removeAttribute(name);
        }

    }



    // ------------------------------------------------------ Protected Methods


    /**
     * Is this attribute name one of the special ones that is added only for
     * included servlets?
     *
     * @param name Attribute name to be tested
     */
    protected boolean isSpecial(String name) {

        for (int i = 0; i < specials.length; i++) {
            if (specials[i].equals(name))
                return true;
        }
        return false;

    }



    /**
     * Override the <code>setAttribute()</code> method of the
     * wrapped request.
     *
     * @param name Name of the attribute to set
     * @param value Value of the attribute to set
     */
    @Override
    public void setAttribute(String name, Object value) {

        synchronized (attributes) {
            attributes.put(name, value);
            if (!isSpecial(name))
                getRequest().setAttribute(name, value);
        }

    }



    // ------------------------------------------------ ServletResponse Methods


    /**
     * Disallow <code>reset()</code> calls on a included response.
     *
     * @exception IllegalStateException if the response has already
     *  been committed
     */
    @Override
    public void reset() {

        // If already committed, the wrapped response will throw ISE
        if (!included || getResponse().isCommitted())
            getResponse().reset();

    }



    /**
     * Disallow <code>setContentLength(int)</code> calls on an included
     * response.
     *
     * @param len The new content length
     */
    @Override
    public void setContentLength(int len) {

        if (!included)
            getResponse().setContentLength(len);

    }



    /**
     * Disallow <code>setContentLengthLong(long)</code> calls on an included
     * response.
     *
     * @param len The new content length
     */
    @Override
    public void setContentLengthLong(long len) {

        if (!included)
            getResponse().setContentLengthLong(len);

    }



    /**
     * Disallow <code>setContentType()</code> calls on an included response.
     *
     * @param type The new content type
     */
    @Override
    public void setContentType(String type) {

        if (!included)
            getResponse().setContentType(type);

    }



    /**
     * Ignore <code>setLocale()</code> calls on an included response.
     *
     * @param loc The new locale
     */
    @Override
    public void setLocale(Locale loc) {
        if (!included)
            getResponse().setLocale(loc);
    }



    /**
     * Ignore <code>setBufferSize()</code> calls on an included response.
     *
     * @param size The buffer size
     */
    @Override
    public void setBufferSize(int size) {
        if (!included)
            getResponse().setBufferSize(size);
    }



    /**
     * Return a String representation of this component.
     */
    @Override
    public String toString() {

        StringBuilder sb = new StringBuilder("StandardEngine[");
        sb.append(getName());
        sb.append("]");
        return (sb.toString());

    }



    @Override
    protected String getDomainInternal() {
        return getName();
    }


    public void addSafeCharacter( char c ) {
        safeCharacters.set( c );
    }



    @Override
    public void setAlgorithm(String algorithm) throws NoSuchAlgorithmException {
        ConcurrentMessageDigest.init(algorithm);
        this.algorithm = algorithm;
    }



    //-------------------------------------------------------- Lifecycle methods
    @Override
    protected final void startInternal() throws LifecycleException {
        setState(LifecycleState.STARTING);
    }


    @Override
    protected final void stopInternal() throws LifecycleException {
        setState(LifecycleState.STOPPING);
    }


    @Override
    protected void startInternal() throws LifecycleException {
        setState(LifecycleState.STARTING);
    }


    @Override
    protected void stopInternal() throws LifecycleException {
        setState(LifecycleState.STOPPING);
    }



    @Override
    protected HashMap<String,JarEntry> getArchiveEntries(boolean single) {
        synchronized (archiveLock) {
            if (archiveEntries == null && !single) {
                JarFile jarFile = null;
                archiveEntries = new HashMap<>();
                try {
                    jarFile = openJarFile();
                    Enumeration<JarEntry> entries = jarFile.entries();
                    while (entries.hasMoreElements()) {
                        JarEntry entry = entries.nextElement();
                        archiveEntries.put(entry.getName(), entry);
                    }
                } catch (IOException ioe) {
                    // Should never happen
                    archiveEntries = null;
                    throw new IllegalStateException(ioe);
                } finally {
                    if (jarFile != null) {
                        closeJarFile();
                    }
                }
            }
            return archiveEntries;
        }
    }



    @Override
    protected JarEntry getArchiveEntry(String pathInArchive) {
        JarFile jarFile = null;
        try {
            jarFile = openJarFile();
            return jarFile.getJarEntry(pathInArchive);
        } catch (IOException ioe) {
            // Should never happen
            throw new IllegalStateException(ioe);
        } finally {
            if (jarFile != null) {
                closeJarFile();
            }
        }
    }


    @Override
    public void addPreResources(WebResourceSet webResourceSet) {
        webResourceSet.setRoot(this);
        preResources.add(webResourceSet);
    }


    void setRoot(WebResourceRoot root);


    @Override
    public void addJarResources(WebResourceSet webResourceSet) {
        webResourceSet.setRoot(this);
        jarResources.add(webResourceSet);
    }


    @Override
    public void addPostResources(WebResourceSet webResourceSet) {
        webResourceSet.setRoot(this);
        postResources.add(webResourceSet);
    }


    protected void addClassResources(WebResourceSet webResourceSet) {
        webResourceSet.setRoot(this);
        classResources.add(webResourceSet);
    }



    // --------------------------------------------------------- Public Methods


    /**
     * Retrieves the next element in the enumeration.
     */
    @Override
    public Binding next()
        throws NamingException {
        return nextElementInternal();
    }


    private Binding nextElementInternal() throws NamingException {
        NamingEntry entry = iterator.next();
        Object value;

        // If the entry is a reference, resolve it
        if (entry.type == NamingEntry.REFERENCE
                || entry.type == NamingEntry.LINK_REF) {
            try {
                value = ctx.lookup(new CompositeName(entry.name));
            } catch (NamingException e) {
                throw e;
            } catch (Exception e) {
                NamingException ne = new NamingException(e.getMessage());
                ne.initCause(e);
                throw ne;
            }
        } else {
            value = entry.value;
        }

        return new Binding(entry.name, value.getClass().getName(), value, true);
    }



    @Override
    public Binding nextElement() {
        try {
            return nextElementInternal();
        } catch (NamingException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }


    @Override
    public MethodInfo getMethodInfo(ELContext context) throws ELException {
        context.notifyBeforeEvaluation(getExpressionString());
        MethodInfo result =
                new MethodInfo(this.expr, this.expectedType, this.paramTypes);
        context.notifyAfterEvaluation(getExpressionString());
        return result;
    }


    @Override
    public String getExpressionString() {
        return this.expr;
    }


    @Override
    public Object invoke(ELContext context, Object[] params) throws ELException {
        context.notifyBeforeEvaluation(getExpressionString());
        Object result;
        if (this.expectedType != null) {
            result = context.convertToType(this.expr, this.expectedType);
        } else {
            result = this.expr;
        }
        context.notifyAfterEvaluation(getExpressionString());
        return result;
    }


    @Override
    public boolean equals(Object obj) {
        return (obj instanceof ValueExpressionLiteral && this
                .equals((ValueExpressionLiteral) obj));
    }


    public boolean equals(ValueExpressionLiteral ve) {
        return (ve != null && (this.value != null && ve.value != null && (this.value == ve.value || this.value
                .equals(ve.value))));
    }


    @Override
    public Object getValue(EvaluationContext ctx)
            throws ELException {
        return this.getFloatingPoint();
    }


    public Number getFloatingPoint() {
        if (this.number == null) {
            try {
                this.number = new Double(this.image);
            } catch (ArithmeticException e0) {
                this.number = new BigDecimal(this.image);
            }
        }
        return this.number;
    }


    @Override
    public Class<?> getType(EvaluationContext ctx)
            throws ELException {
        return this.getFloatingPoint().getClass();
    }


    @Override
    public Class<?> getType(EvaluationContext ctx)
            throws ELException {
        return this.getInteger().getClass();
    }


    protected Number getInteger() {
        if (this.number == null) {
            try {
                this.number = new Long(this.image);
            } catch (ArithmeticException e1) {
                this.number = new BigInteger(this.image);
            }
        }
        return number;
    }


    @Override
    public Object getValue(EvaluationContext ctx)
            throws ELException {
        return this.getInteger();
    }


    @Override
    public void handlePageException(Exception ex) throws IOException,
            ServletException {
        // Should never be called since handleException() called with a
        // Throwable in the generated servlet.
        handlePageException((Throwable) ex);
    }


    @Override
    public void handlePageException(Throwable t) throws IOException,
            ServletException {
        invokingJspCtxt.handlePageException(t);
    }


    /**
     * Generated Servlet and Tag Handler implementations call this method to
     * retrieve an instance of the ProtectedFunctionMapper.
     *
     * @return A new protected function mapper.
     */
    public static ProtectedFunctionMapper getInstance() {
        ProtectedFunctionMapper funcMapper = new ProtectedFunctionMapper();
        funcMapper.fnmap = new HashMap<>();
        return funcMapper;
    }


    /**
     * Creates an instance for this class, and stores the Method for the given
     * EL function prefix and name. This method is used for the case when there
     * is only one function in the EL expression.
     *
     * @param fnQName
     *            The EL function qualified name (including prefix)
     * @param c
     *            The class containing the Java method
     * @param methodName
     *            The name of the Java method
     * @param args
     *            The arguments of the Java method
     * @throws RuntimeException
     *             if no method with the given signature could be found.
     * @return the mapped function
     */
    public static ProtectedFunctionMapper getMapForFunction(String fnQName,
            final Class<?> c, final String methodName, final Class<?>[] args) {
        java.lang.reflect.Method method = null;
        ProtectedFunctionMapper funcMapper = new ProtectedFunctionMapper();
        // Skip if null values were passed in. They indicate a function
        // added via a lambda or ImportHandler; nether of which need to be
        // placed in the Map.
        if (fnQName != null) {
            try {
                method = c.getMethod(methodName, args);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException(
                        "Invalid function mapping - no such method: "
                                + e.getMessage());
            }
        }
        funcMapper.theMethod = method;
        return funcMapper;
    }



    // ----------------------------------------------------------- Constructors

    /**
     * Create a new instance of this ServletContext implementation.
     *
     * @param aLogWriter PrintWriter which is used for <code>log()</code> calls
     * @param aResourceBaseURL Resource base URL
     * @param classLoader   Class loader for this {@link ServletContext}
     * @param validate      Should a validating parser be used to parse web.xml?
     * @param blockExternal Should external entities be blocked when parsing
     *                      web.xml?
     * @throws JasperException An error occurred building the merged web.xml
     */
    public JspCServletContext(PrintWriter aLogWriter, URL aResourceBaseURL,
            ClassLoader classLoader, boolean validate, boolean blockExternal)
            throws JasperException {

        myAttributes = new HashMap<>();
        myParameters = new ConcurrentHashMap<>();
        myParameters.put(Constants.XML_BLOCK_EXTERNAL_INIT_PARAM,
                String.valueOf(blockExternal));
        myLogWriter = aLogWriter;
        myResourceBaseURL = aResourceBaseURL;
        this.loader = classLoader;
        this.webXml = buildMergedWebXml(validate, blockExternal);
        jspConfigDescriptor = webXml.getJspConfigDescriptor();
    }



    /**
     * Log the specified message.
     *
     * @param message The message to be logged
     */
    @Override
    public void log(String message) {
        myLogWriter.println(message);
    }



    /**
     * Log the specified message and exception.
     *
     * @param exception The exception to be logged
     * @param message The message to be logged
     *
     * @deprecated Use log(String,Throwable) instead
     */
    @Override
    @Deprecated
    public void log(Exception exception, String message) {
        log(message, exception);
    }



    /**
     * Log the specified message and exception.
     *
     * @param message The message to be logged
     * @param exception The exception to be logged
     */
    @Override
    public void log(String message, Throwable exception) {
        myLogWriter.println(message);
        exception.printStackTrace(myLogWriter);
    }



    boolean isDescendant(AbstractStream stream) {
        if (childStreams.contains(stream)) {
            return true;
        }
        for (AbstractStream child : childStreams) {
            if (child.isDescendant(stream)) {
                return true;
            }
        }
        return false;
    }



    public long getMaxConcurrentStreams() {
        return getMax(Setting.MAX_CONCURRENT_STREAMS);
    }



    private synchronized long getMax(Setting setting) {
        Long pendingValue = pending.get(setting);
        long currentValue = current.get(setting).longValue();
        if (pendingValue == null) {
            return currentValue;
        } else {
            return Math.max(pendingValue.longValue(), currentValue);
        }
    }



    public int getInitialWindowSize() {
        return getMaxInt(Setting.INITIAL_WINDOW_SIZE);
    }



    private synchronized int getMaxInt(Setting setting) {
        long result = getMax(setting);
        if (result > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        } else {
            return (int) result;
        }
    }



    public int getMaxFrameSize() {
        return getMaxInt(Setting.MAX_FRAME_SIZE);
    }



    public long getMaxHeaderListSize() {
        return getMax(Setting.MAX_HEADER_LIST_SIZE);
    }



    /**
     * Remove a notification event listener from this MBean.
     *
     * @param listener The listener to be removed (any and all registrations
     *  for this listener will be eliminated)
     *
     * @exception ListenerNotFoundException if this listener is not
     *  registered in the MBean
     */
    @Override
    public void removeNotificationListener(NotificationListener listener)
        throws ListenerNotFoundException {

        synchronized (entries) {
            Iterator<BaseNotificationBroadcasterEntry> items =
                entries.iterator();
            while (items.hasNext()) {
                BaseNotificationBroadcasterEntry item = items.next();
                if (item.listener == listener)
                    items.remove();
            }
        }

    }



    /**
     * Remove a notification event listener from this MBean.
     *
     * @param listener The listener to be removed (any and all registrations
     *  for this listener will be eliminated)
     *
     * @exception ListenerNotFoundException if this listener is not
     *  registered in the MBean
     */
    @Override
    public void removeNotificationListener(NotificationListener listener)
        throws ListenerNotFoundException {

        if (listener == null)
            throw new IllegalArgumentException("Listener is null");

        if (generalBroadcaster != null) {
            generalBroadcaster.removeNotificationListener(listener);
        }

        if (attributeBroadcaster != null) {
            attributeBroadcaster.removeNotificationListener(listener);
        }
     }



    // ------------------------------------------------------ Protected Methods


    public int getWriteBufSize() {
        return socketProperties.getTxBufSize();
    }


    public int getTxBufSize() {
        return txBufSize.intValue();
    }


    public int getReadBufSize() {
        return socketProperties.getRxBufSize();
    }


    public int getRxBufSize() {
        return rxBufSize.intValue();
    }



    // ------------------------------------------------------ Protected Methods


    public int getWriteBufSize() {
        return socketProperties.getTxBufSize();
    }


    public int getReadBufSize() {
        return socketProperties.getRxBufSize();
    }


    @Override
    public SSLSupport getSSLSupport(SSLSession session) {
        return new JSSESupport(session);
    }


    @Override
    public SSLSupport getSSLSupport(SSLSession session) {
        return new JSSESupport(session);
    }


    @Override
    public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException {
        unwrap().checkValidity();
    }


    @Override
    public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
        unwrap().checkValidity(date);
    }


    private X509Certificate unwrap() {
        X509Certificate wrapped = this.wrapped;
        if (wrapped == null) {
            try {
                wrapped = this.wrapped = (X509Certificate) OpenSSLContext.X509_CERT_FACTORY.generateCertificate(
                        new ByteArrayInputStream(bytes));
            } catch (CertificateException e) {
                throw new IllegalStateException(e);
            }
        }
        return wrapped;
    }


    @Override
    public int getVersion() {
        return unwrap().getVersion();
    }


    @Override
    public BigInteger getSerialNumber() {
        return unwrap().getSerialNumber();
    }


    @Override
    public Principal getIssuerDN() {
        return unwrap().getIssuerDN();
    }


    @Override
    public Principal getSubjectDN() {
        return unwrap().getSubjectDN();
    }


    @Override
    public Date getNotBefore() {
        return unwrap().getNotBefore();
    }


    @Override
    public Date getNotAfter() {
        return unwrap().getNotAfter();
    }


    @Override
    public byte[] getTBSCertificate() throws CertificateEncodingException {
        return unwrap().getTBSCertificate();
    }


    @Override
    public byte[] getSignature() {
        return unwrap().getSignature();
    }


    @Override
    public String getSigAlgName() {
        return unwrap().getSigAlgName();
    }


    @Override
    public String getSigAlgOID() {
        return unwrap().getSigAlgOID();
    }


    @Override
    public byte[] getSigAlgParams() {
        return unwrap().getSigAlgParams();
    }


    @Override
    public boolean[] getIssuerUniqueID() {
        return unwrap().getIssuerUniqueID();
    }


    @Override
    public boolean[] getSubjectUniqueID() {
        return unwrap().getSubjectUniqueID();
    }


    @Override
    public boolean[] getKeyUsage() {
        return unwrap().getKeyUsage();
    }


    @Override
    public int getBasicConstraints() {
        return unwrap().getBasicConstraints();
    }


    @Override
    public void verify(PublicKey key)
            throws CertificateException, NoSuchAlgorithmException,
            InvalidKeyException, NoSuchProviderException, SignatureException {
        unwrap().verify(key);
    }


    @Override
    public void verify(PublicKey key, String sigProvider)
            throws CertificateException, NoSuchAlgorithmException, InvalidKeyException,
            NoSuchProviderException, SignatureException {
        unwrap().verify(key, sigProvider);
    }


    @Override
    public String toString() {
        return unwrap().toString();
    }


    @Override
    public PublicKey getPublicKey() {
        return unwrap().getPublicKey();
    }


    @Override
    public boolean hasUnsupportedCriticalExtension() {
        return unwrap().hasUnsupportedCriticalExtension();
    }


    @Override
    public Set<String> getCriticalExtensionOIDs() {
        return unwrap().getCriticalExtensionOIDs();
    }


    @Override
    public Set<String> getNonCriticalExtensionOIDs() {
        return unwrap().getNonCriticalExtensionOIDs();
    }


    @Override
    public byte[] getExtensionValue(String oid) {
        return unwrap().getExtensionValue(oid);
    }


    @Override
    public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType); } catch (SQLException e) { handleException(e); } }


    @Override
    public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( parameterIndex,  sqlType,  scale); } catch (SQLException e) { handleException(e); } }


    @Override
    public void registerOutParameter(int paramIndex, int sqlType, String typeName) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter( paramIndex,  sqlType,  typeName); } catch (SQLException e) { handleException(e); } }


    @Override
    public void registerOutParameter(String parameterName, int sqlType) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType); } catch (SQLException e) { handleException(e); } }


    @Override
    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, scale); } catch (SQLException e) { handleException(e); } }


    @Override
    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).registerOutParameter(parameterName, sqlType, typeName); } catch (SQLException e) { handleException(e); } }


    @Override
    public boolean wasNull() throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).wasNull(); } catch (SQLException e) { handleException(e); return false; } }


    @Override
    public String getString(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public String getString(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getString(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public boolean getBoolean(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean( parameterIndex); } catch (SQLException e) { handleException(e); return false; } }


    @Override
    public boolean getBoolean(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBoolean(parameterName); } catch (SQLException e) { handleException(e); return false; } }


    @Override
    public byte getByte(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public byte getByte(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getByte(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public short getShort(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public short getShort(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getShort(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public int getInt(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public int getInt(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getInt(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public long getLong(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public long getLong(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getLong(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public float getFloat(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public float getFloat(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getFloat(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public double getDouble(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble( parameterIndex); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public double getDouble(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDouble(parameterName); } catch (SQLException e) { handleException(e); return 0; } }


    @Override
    public BigDecimal getBigDecimal(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public BigDecimal getBigDecimal(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBigDecimal(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public byte[] getBytes(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public byte[] getBytes(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBytes(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Date getDate(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Date getDate(int parameterIndex, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Date getDate(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Date getDate(String parameterName, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getDate(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Time getTime(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Time getTime(int parameterIndex, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Time getTime(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Time getTime(String parameterName, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTime(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Timestamp getTimestamp(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp( parameterIndex,  cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Timestamp getTimestamp(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getTimestamp(parameterName, cal); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Object getObject(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Object getObject(int i, Map<String,Class<?>> map) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject( i, map); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Object getObject(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Object getObject(String parameterName, Map<String,Class<?>> map) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getObject(parameterName, map); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public <T> T getObject(int parameterIndex, Class<T> type)
            throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getObject(parameterIndex, type);
}
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public <T> T getObject(String parameterName, Class<T> type)
            throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getObject(parameterName, type);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public Ref getRef(int i) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef( i); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Ref getRef(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getRef(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Blob getBlob(int i) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob( i); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Blob getBlob(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getBlob(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Clob getClob(int i) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob( i); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Clob getClob(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getClob(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Array getArray(int i) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray( i); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public Array getArray(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getArray(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public URL getURL(int parameterIndex) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterIndex); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public URL getURL(String parameterName) throws SQLException
    { checkOpen(); try { return ((CallableStatement)getDelegate()).getURL(parameterName); } catch (SQLException e) { handleException(e); return null; } }


    @Override
    public void setURL(String parameterName, URL val) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setURL(parameterName, val); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setNull(String parameterName, int sqlType) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setNull(parameterName, sqlType, typeName); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setBoolean(String parameterName, boolean x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setBoolean(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setByte(String parameterName, byte x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setByte(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setShort(String parameterName, short x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setShort(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setInt(String parameterName, int x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setInt(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setLong(String parameterName, long x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setLong(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setFloat(String parameterName, float x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setFloat(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setDouble(String parameterName, double x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setDouble(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setBigDecimal(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setString(String parameterName, String x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setString(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setBytes(String parameterName, byte [] x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setBytes(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setDate(String parameterName, Date x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setDate(String parameterName, Date x, Calendar cal) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setDate(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setTime(String parameterName, Time x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setTime(String parameterName, Time x, Calendar cal) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setTime(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setTimestamp(String parameterName, Timestamp x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setTimestamp(String parameterName, Timestamp x, Calendar cal) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setTimestamp(parameterName, x, cal); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setAsciiStream(String parameterName, InputStream x, int length) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setAsciiStream(parameterName, x, length); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setAsciiStream(String parameterName, InputStream inputStream, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setAsciiStream(String parameterName, InputStream inputStream) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setAsciiStream(parameterName, inputStream);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setBinaryStream(String parameterName, InputStream x, int length) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setBinaryStream(parameterName, x, length); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setBinaryStream(String parameterName, InputStream inputStream, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setBinaryStream(String parameterName, InputStream inputStream) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setBinaryStream(parameterName, inputStream);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType, scale); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x, targetSqlType); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setObject(String parameterName, Object x) throws SQLException
    { checkOpen(); try { ((CallableStatement)getDelegate()).setObject(parameterName, x); } catch (SQLException e) { handleException(e); } }


    @Override
    public void setCharacterStream(String parameterName, Reader reader, int length) throws SQLException
    { checkOpen(); ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length); }


    @Override
    public void setCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setCharacterStream(String parameterName, Reader reader) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setCharacterStream(parameterName, reader);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }



    @Override
    public RowId getRowId(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getRowId(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public RowId getRowId(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getRowId(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public void setRowId(String parameterName, RowId value) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setRowId(parameterName, value);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNString(String parameterName, String value) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNString(parameterName, value);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNCharacterStream(String parameterName, Reader reader) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNCharacterStream(parameterName, reader);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNClob(String parameterName, NClob value) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNClob(parameterName, value);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNClob(parameterName, reader, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setNClob(String parameterName, Reader reader) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setNClob(parameterName, reader);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setClob(String parameterName, Reader reader, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setClob(parameterName, reader, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setClob(String parameterName, Clob clob) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setClob(parameterName, clob);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setClob(String parameterName, Reader reader) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setClob(parameterName, reader);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream, length);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setBlob(String parameterName, Blob blob) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setBlob(parameterName, blob);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setBlob(parameterName, inputStream);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public NClob getNClob(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNClob(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public NClob getNClob(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNClob(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public void setSQLXML(String parameterName, SQLXML value) throws SQLException {
        checkOpen();
        try {
            ((CallableStatement)getDelegate()).setSQLXML(parameterName, value);
        }
        catch (SQLException e) {
            handleException(e);
        }
    }


    @Override
    public SQLXML getSQLXML(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getSQLXML(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public SQLXML getSQLXML(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getSQLXML(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public String getNString(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNString(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public String getNString(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNString(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public Reader getNCharacterStream(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public Reader getNCharacterStream(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getNCharacterStream(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public Reader getCharacterStream(int parameterIndex) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getCharacterStream(parameterIndex);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    @Override
    public Reader getCharacterStream(String parameterName) throws SQLException {
        checkOpen();
        try {
            return ((CallableStatement)getDelegate()).getCharacterStream(parameterName);
        }
        catch (SQLException e) {
            handleException(e);
            return null;
        }
    }


    /**
     * Can be used to clear cached state when it is known that the underlying
     * connection may have been accessed directly.
     */
    public void clearCachedState() {
        _autoCommitCached = null;
        _readOnlyCached = null;
        if (_conn instanceof DelegatingConnection) {
            ((DelegatingConnection<?>)_conn).clearCachedState();
        }
    }


    protected void activate() throws SQLException {
        if(_stmt instanceof DelegatingStatement) {
            ((DelegatingStatement)_stmt).activate();
        }
    }


    protected void passivate() throws SQLException {
        if(_stmt instanceof DelegatingStatement) {
            ((DelegatingStatement)_stmt).passivate();
        }
    }



    // ----------------------------------------------------------------------
    // Instrumentation Methods

    /**
     * @return the number of active connections in the pool.
     */
    public int getNumActive() {
        return pool == null ? 0 : pool.getNumActive();
    }


    /**
     * Returns the number of instances currently borrowed from but not yet
     * returned to the pool corresponding to the given <code>key</code>.
     * Returns a negative value if this information is not available.
     *
     * @param key the key to query
     * @return the number of instances currently borrowed from but not yet
     * returned to the pool corresponding to the given <code>key</code>.
=     */
    int getNumActive(K key);


    /**
     * Returns the total number of instances current borrowed from this pool but
     * not yet returned. Returns a negative value if this information is not
     * available.
     * @return the total number of instances current borrowed from this pool but
     * not yet returned.
     */
    int getNumActive();


    @Override
    public long getLastBorrowTime() {
        return pooledObject.getLastBorrowTime();
    }


    /**
     * Obtain the time the wrapped object was last borrowed.
     *
     * @return The time the object was last borrowed
     */
    long getLastBorrowTime();


    @Override
    public String getLastBorrowTimeFormatted() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
        return sdf.format(Long.valueOf(pooledObject.getLastBorrowTime()));
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        super.toStringAppendFields(builder);
        builder.append(", maxIdlePerKey=");
        builder.append(maxIdlePerKey);
        builder.append(", minIdlePerKey=");
        builder.append(minIdlePerKey);
        builder.append(", maxTotalPerKey=");
        builder.append(maxTotalPerKey);
        builder.append(", factory=");
        builder.append(factory);
        builder.append(", fairness=");
        builder.append(fairness);
        builder.append(", poolMap=");
        builder.append(poolMap);
        builder.append(", poolKeyList=");
        builder.append(poolKeyList);
        builder.append(", keyLock=");
        builder.append(keyLock);
        builder.append(", numTotal=");
        builder.append(numTotal);
        builder.append(", evictionKeyIterator=");
        builder.append(evictionKeyIterator);
        builder.append(", evictionKey=");
        builder.append(evictionKey);
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        builder.append("maxTotal=");
        builder.append(maxTotal);
        builder.append(", blockWhenExhausted=");
        builder.append(blockWhenExhausted);
        builder.append(", maxWaitMillis=");
        builder.append(maxWaitMillis);
        builder.append(", lifo=");
        builder.append(lifo);
        builder.append(", fairness=");
        builder.append(fairness);
        builder.append(", testOnCreate=");
        builder.append(testOnCreate);
        builder.append(", testOnBorrow=");
        builder.append(testOnBorrow);
        builder.append(", testOnReturn=");
        builder.append(testOnReturn);
        builder.append(", testWhileIdle=");
        builder.append(testWhileIdle);
        builder.append(", timeBetweenEvictionRunsMillis=");
        builder.append(timeBetweenEvictionRunsMillis);
        builder.append(", numTestsPerEvictionRun=");
        builder.append(numTestsPerEvictionRun);
        builder.append(", minEvictableIdleTimeMillis=");
        builder.append(minEvictableIdleTimeMillis);
        builder.append(", softMinEvictableIdleTimeMillis=");
        builder.append(softMinEvictableIdleTimeMillis);
        builder.append(", evictionPolicy=");
        builder.append(evictionPolicy);
        builder.append(", closeLock=");
        builder.append(closeLock);
        builder.append(", closed=");
        builder.append(closed);
        builder.append(", evictionLock=");
        builder.append(evictionLock);
        builder.append(", evictor=");
        builder.append(evictor);
        builder.append(", evictionIterator=");
        builder.append(evictionIterator);
        builder.append(", factoryClassLoader=");
        builder.append(factoryClassLoader);
        builder.append(", oname=");
        builder.append(oname);
        builder.append(", creationStackTrace=");
        builder.append(creationStackTrace);
        builder.append(", borrowedCount=");
        builder.append(borrowedCount);
        builder.append(", returnedCount=");
        builder.append(returnedCount);
        builder.append(", createdCount=");
        builder.append(createdCount);
        builder.append(", destroyedCount=");
        builder.append(destroyedCount);
        builder.append(", destroyedByEvictorCount=");
        builder.append(destroyedByEvictorCount);
        builder.append(", destroyedByBorrowValidationCount=");
        builder.append(destroyedByBorrowValidationCount);
        builder.append(", activeTimes=");
        builder.append(activeTimes);
        builder.append(", idleTimes=");
        builder.append(idleTimes);
        builder.append(", waitTimes=");
        builder.append(waitTimes);
        builder.append(", maxBorrowWaitTimeMillis=");
        builder.append(maxBorrowWaitTimeMillis);
        builder.append(", swallowedExceptionListener=");
        builder.append(swallowedExceptionListener);
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        super.toStringAppendFields(builder);
        builder.append(", minIdlePerKey=");
        builder.append(minIdlePerKey);
        builder.append(", maxIdlePerKey=");
        builder.append(maxIdlePerKey);
        builder.append(", maxTotalPerKey=");
        builder.append(maxTotalPerKey);
        builder.append(", maxTotal=");
        builder.append(maxTotal);
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        builder.append("lifo=");
        builder.append(lifo);
        builder.append(", fairness=");
        builder.append(fairness);
        builder.append(", maxWaitMillis=");
        builder.append(maxWaitMillis);
        builder.append(", minEvictableIdleTimeMillis=");
        builder.append(minEvictableIdleTimeMillis);
        builder.append(", softMinEvictableIdleTimeMillis=");
        builder.append(softMinEvictableIdleTimeMillis);
        builder.append(", numTestsPerEvictionRun=");
        builder.append(numTestsPerEvictionRun);
        builder.append(", evictionPolicyClassName=");
        builder.append(evictionPolicyClassName);
        builder.append(", testOnCreate=");
        builder.append(testOnCreate);
        builder.append(", testOnBorrow=");
        builder.append(testOnBorrow);
        builder.append(", testOnReturn=");
        builder.append(testOnReturn);
        builder.append(", testWhileIdle=");
        builder.append(testWhileIdle);
        builder.append(", timeBetweenEvictionRunsMillis=");
        builder.append(timeBetweenEvictionRunsMillis);
        builder.append(", blockWhenExhausted=");
        builder.append(blockWhenExhausted);
        builder.append(", jmxEnabled=");
        builder.append(jmxEnabled);
        builder.append(", jmxNamePrefix=");
        builder.append(jmxNamePrefix);
        builder.append(", jmxNameBase=");
        builder.append(jmxNameBase);
    }


    @Override
    public GenericKeyedObjectPoolConfig clone() {
        try {
            return (GenericKeyedObjectPoolConfig) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(); // Can't happen
        }
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        super.toStringAppendFields(builder);
        builder.append(", factoryType=");
        builder.append(factoryType);
        builder.append(", maxIdle=");
        builder.append(maxIdle);
        builder.append(", minIdle=");
        builder.append(minIdle);
        builder.append(", factory=");
        builder.append(factory);
        builder.append(", allObjects=");
        builder.append(allObjects);
        builder.append(", createCount=");
        builder.append(createCount);
        builder.append(", idleObjects=");
        builder.append(idleObjects);
        builder.append(", abandonedConfig=");
        builder.append(abandonedConfig);
    }


    @Override
    protected void toStringAppendFields(StringBuilder builder) {
        super.toStringAppendFields(builder);
        builder.append(", maxTotal=");
        builder.append(maxTotal);
        builder.append(", maxIdle=");
        builder.append(maxIdle);
        builder.append(", minIdle=");
        builder.append(minIdle);
    }


    @Override
    public GenericObjectPoolConfig clone() {
        try {
            return (GenericObjectPoolConfig) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(); // Can't happen
        }
    }


    @Override
    public final void debug(Object message) {
        log(Level.FINE, String.valueOf(message), null);
    }


    @Override
    public final void debug(Object message, Throwable t) {
        log(Level.FINE, String.valueOf(message), t);
    }


    @Override
    public final void trace(Object message) {
        log(Level.FINER, String.valueOf(message), null);
    }


    @Override
    public final void trace(Object message, Throwable t) {
        log(Level.FINER, String.valueOf(message), t);
    }


    @Override
    public final void info(Object message) {
        log(Level.INFO, String.valueOf(message), null);
    }


    @Override
    public final void info(Object message, Throwable t) {
        log(Level.INFO, String.valueOf(message), t);
    }


    @Override
    public final void warn(Object message) {
        log(Level.WARNING, String.valueOf(message), null);
    }


    @Override
    public final void warn(Object message, Throwable t) {
        log(Level.WARNING, String.valueOf(message), t);
    }


    @Override
    public final void error(Object message) {
        log(Level.SEVERE, String.valueOf(message), null);
    }


    @Override
    public final void error(Object message, Throwable t) {
        log(Level.SEVERE, String.valueOf(message), t);
    }


    @Override
    public final void fatal(Object message) {
        log(Level.SEVERE, String.valueOf(message), null);
    }


    @Override
    public final void fatal(Object message, Throwable t) {
        log(Level.SEVERE, String.valueOf(message), t);
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((home == null) ? 0 : home.hashCode());
        result = prime * result + ((link == null) ? 0 : link.hashCode());
        result = prime * result + ((remote == null) ? 0 : remote.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result +
                ((description == null) ? 0 : description.hashCode());
        result = prime * result +
                ((injectionTargets == null) ? 0 : injectionTargets.hashCode());
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result +
                ((properties == null) ? 0 : properties.hashCode());
        result = prime * result + ((type == null) ? 0 : type.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + (override ? 1231 : 1237);
        result = prime * result + ((value == null) ? 0 : value.hashCode());
        return result;
    }


    /**
     * Set a configured property.
     * @param name The property name
     * @param value The property value
     */
    public void setProperty(String name, String value) {
        this.setProperty(name, (Object) value);
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result +
                ((handlerclass == null) ? 0 : handlerclass.hashCode());
        result = prime * result +
                ((portNames == null) ? 0 : portNames.hashCode());
        result = prime * result +
                ((soapHeaders == null) ? 0 : soapHeaders.hashCode());
        result = prime * result +
                ((soapRoles == null) ? 0 : soapRoles.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((home == null) ? 0 : home.hashCode());
        result = prime * result + ((link == null) ? 0 : link.hashCode());
        result = prime * result + ((local == null) ? 0 : local.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((auth == null) ? 0 : auth.hashCode());
        result = prime * result +
                ((closeMethod == null) ? 0 : closeMethod.hashCode());
        result = prime * result + ((scope == null) ? 0 : scope.hashCode());
        result = prime * result + (singleton ? 1231 : 1237);
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + (override ? 1231 : 1237);
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((factory == null) ? 0 : factory.hashCode());
        result = prime * result + ((global == null) ? 0 : global.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result +
                ((displayname == null) ? 0 : displayname.hashCode());
        result = prime * result +
                ((handlers == null) ? 0 : handlers.hashCode());
        result = prime *
                result +
                ((jaxrpcmappingfile == null) ? 0 : jaxrpcmappingfile.hashCode());
        result = prime * result +
                ((largeIcon == null) ? 0 : largeIcon.hashCode());
        result = prime * result +
                ((serviceInterface == null) ? 0 : serviceInterface.hashCode());
        result = prime * result + Arrays.hashCode(serviceqname);
        result = prime * result +
                ((smallIcon == null) ? 0 : smallIcon.hashCode());
        result = prime * result +
                ((wsdlfile == null) ? 0 : wsdlfile.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result +
                ((displayName == null) ? 0 : displayName.hashCode());
        result = prime * result +
                ((largeIcon == null) ? 0 : largeIcon.hashCode());
        result = prime * result +
                ((smallIcon == null) ? 0 : smallIcon.hashCode());
        return result;
    }



    @Override
    public int hashCode() {
        final int prime = 31;
        int result = super.hashCode();
        result = prime * result + ((link == null) ? 0 : link.hashCode());
        result = prime * result + ((usage == null) ? 0 : usage.hashCode());
        return result;
    }



    public void setTldSkip(String tldSkip) {
        this.tldSkip = tldSkip;
        Lock writeLock = configurationLock.writeLock();
        writeLock.lock();
        try {
            populateSetFromAttribute(tldSkip, tldSkipSet);
        } finally {
            writeLock.unlock();
        }
    }


    private static void populateSetFromAttribute(String attribute, Set<String> set) {
        set.clear();
        if (attribute != null) {
            StringTokenizer tokenizer = new StringTokenizer(attribute, ",");
            while (tokenizer.hasMoreElements()) {
                String token = tokenizer.nextToken().trim();
                if (token.length() > 0) {
                    set.add(token);
                }
            }
        }
    }



    public void setTldScan(String tldScan) {
        this.tldScan = tldScan;
        Lock writeLock = configurationLock.writeLock();
        writeLock.lock();
        try {
            populateSetFromAttribute(tldScan, tldScanSet);
        } finally {
            writeLock.unlock();
        }
    }



    public void setPluggabilitySkip(String pluggabilitySkip) {
        this.pluggabilitySkip = pluggabilitySkip;
        Lock writeLock = configurationLock.writeLock();
        writeLock.lock();
        try {
            populateSetFromAttribute(pluggabilitySkip, pluggabilitySkipSet);
        } finally {
            writeLock.unlock();
        }
    }



    public void setPluggabilityScan(String pluggabilityScan) {
        this.pluggabilityScan = pluggabilityScan;
        Lock writeLock = configurationLock.writeLock();
        writeLock.lock();
        try {
            populateSetFromAttribute(pluggabilityScan, pluggabilityScanSet);
        } finally {
            writeLock.unlock();
        }
    }

    @Override
    public ClassLoader run() {
        return Thread.currentThread().getContextClassLoader();
    }


    @Override
    public Void run() {
        Thread.currentThread().setContextClassLoader(cl);
        return null;
    }



    @Override
    protected Object convert(ByteBuffer message) {
        byte[] array = new byte[message.remaining()];
        message.get(array);
        if (isForInputStream) {
            return new ByteArrayInputStream(array);
        } else {
            return array;
        }
    }


    @Override
    protected Object decode(PongMessage message) {
        // Never decoded
        return null;
    }



    @Override
    protected Object convert(String message) {
        return new StringReader(message);
    }
